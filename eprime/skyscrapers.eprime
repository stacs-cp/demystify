language ESSENCE' 1.0
$ Skyscrapers puzzle solver, originally modelled by Ian Gent
$ see https://www.conceptispuzzles.com/index.aspx?uri=puzzle/skyscrapers/techniques
$ based on model by Andras and Joan for Futoshiki


$$ Input is SIZE, which is dimension of square grid
$$ And CLUES, 4xSIZE array of clues
$ CLUES[1,..] is clues along left of grid pointing right, 0 indicating no clue
$ CLUES[2,..] is clues along top of grid pointing down
$ CLUES[3,..] is clues along right of grid pointing left
$ CLUES[4,..] is clues along bottom of grid poiting up.

$$ To explain the model, just think of one dimension at first, 
$$ The idea of the model is to have auxiliary variables which give the maximum number 
$$ seen in that row to date, with a dummy value of zero at the zeroth cell.  
$$ The skyscraper number is simply the number of times the max number increments.

$$ For all four dimensions I decided it would be too risky to try to change the 
$$ starting point and deltas in each dimension, and annoying/buggy to type out the same 
$$ constraints 4 times.  So instead I just form 4 copies of the original field, each one 
$$ transposed/reversed as necessary to make the same set of constraints give the desired
$$ direction in the original field.  This makes sense as I know that Savile Row is going to 
$$ identify all these variables anyway so there will not be surplus variables in the solver

$ we are assuming always a square grid.

given SIZE: int(1..)

$ the numeric values specified in the puzzle

letting   VALUES be domain int( 0..SIZE )
letting   RANGE  be domain int( 1..SIZE )

given     CLUES : matrix indexed by [int(1..4),RANGE] of VALUES

given GRID : matrix indexed by [RANGE,RANGE] of VALUES


$#VAR field

find      field  : matrix indexed by [RANGE, RANGE] of RANGE

$ -------- Reified variables -----------------------------
$#CON row_alldiff "all elements in row {a[0]} must be different"

find row_alldiff : matrix indexed by [RANGE] of bool

$#CON col_alldiff "all elements in column {a[0]} must be different"

find col_alldiff : matrix indexed by [RANGE] of bool

$#CON clues_left_on "the count for {['left','top','right','bottom'][a[0]-1]} {a[1]} is {params['CLUES'][a[0]-1][a[1]-1]}"
find clues_left_on : matrix indexed by [int(1..4),RANGE] of bool

$#AUX max_left
find max_left : matrix indexed by [int(1..4),RANGE, VALUES] of VALUES

$#AUX sky_left
find sky_left : matrix indexed by [int(1..4),RANGE] of RANGE

$ four versions of field in different directions
$ index 1 is original field
$ index 2 is transpose so left corresponds to top hand in original
$ index 3 is reversed original so left corresponds to right hand in original
$ index 4 is transpose reversed so left corresponds to bottom in original

$#AUX variant_fields
find variant_fields : matrix indexed by [int(1..4),RANGE,RANGE] of RANGE 

such that

$ port over hints grid to final solution
    forAll row : RANGE .
        forAll col : RANGE .
	 		((GRID[row,col] > 0) -> (field[row,col] = GRID[row,col])),

$ all rows have to be different
    forAll row : RANGE .
	row_alldiff[row] -> allDiff(field[row,..]),

$ all columns have to be different
    forAll col : RANGE .
	col_alldiff[col] -> allDiff(field[..,col]),	 

forAll row, col: RANGE . 
    variant_fields[1,row,col] = field[row,col] /\    
    variant_fields[2,row,col] = field[col,row] /\
    variant_fields[3,row,col] = field[row,SIZE+1-col] /\
    variant_fields[4,row,col] = field[SIZE+1-col,row],

forAll i : int(1..4) . 
    forAll row : RANGE . 
        max_left[i,row,0] = 0 /\
        forall col : RANGE . 
             max_left[i,row,col] = max(max_left[i,row,col-1],variant_fields[i,row,col]) ,

forAll i : int(1..4) . 
    forAll row : RANGE . 
        sky_left[i,row] = sum col : RANGE . toInt( max_left[i,row,col-1] < max_left[i,row,col] ) ,

forAll i : int(1..4) . 
    forAll row : RANGE . 
        clues_left_on[i,row] -> (CLUES[i,row] > 0 -> (sky_left[i,row]=CLUES[i,row] )) , 

$ insist that probelm problem is sat

$and([and(row_alldiff), and(col_alldiff), and(flatten(clues_left_on)) ]),

true
